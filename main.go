package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"net/http"
	"os"
	"strings"

	tgbotapi "github.com/go-telegram-bot-api/telegram-bot-api/v5"
	"github.com/joho/godotenv"
)

func init() {
	// loads values from .env into the system
	if err := godotenv.Load(); err != nil {
		log.Println("No .env file found")
	}
}

// struct of Weather JSON
type Weather []struct {
	ID          int    `json:"id"`
	Main        string `json:"main"`
	Description string `json:"description"`
	Icon        string `json:"icon"`
}

// struct of Weather JSON
type AutoGenerated struct {
	Coord struct {
		Lon float64 `json:"lon"`
		Lat float64 `json:"lat"`
	} `json:"coord"`
	Weather Weather `json:"weather"`
	Base    string  `json:"base"`
	Main    struct {
		Temp      float64 `json:"temp"`
		FeelsLike float64 `json:"feels_like"`
		TempMin   float64 `json:"temp_min"`
		TempMax   float64 `json:"temp_max"`
		Pressure  int     `json:"pressure"`
		Humidity  int     `json:"humidity"`
	} `json:"main"`
	Visibility int `json:"visibility"`
	Wind       struct {
		Speed float64 `json:"speed"`
		Deg   int     `json:"deg"`
		Gust  int     `json:"gust"`
	} `json:"wind"`
	Clouds struct {
		All int `json:"all"`
	} `json:"clouds"`
	Dt  int `json:"dt"`
	Sys struct {
		Type    int    `json:"type"`
		ID      int    `json:"id"`
		Country string `json:"country"`
		Sunrise int    `json:"sunrise"`
		Sunset  int    `json:"sunset"`
	} `json:"sys"`
	Timezone int    `json:"timezone"`
	ID       int    `json:"id"`
	Name     string `json:"name"`
	Cod      int    `json:"cod"`
}

// Get weather date from WeatherFree API
func getWeatherDate() (string, string, string, string) {
	Weather_API, exist := os.LookupEnv("WEATHER_API")
	if !exist {
		log.Println("Weather API not found")
	}
	response, err := http.Get(Weather_API)
	if err != nil {
		log.Println(err.Error())
		os.Exit(1)
	}
	defer response.Body.Close()

	responseData, err := ioutil.ReadAll(response.Body)
	if err != nil {
		log.Println(err.Error())
		os.Exit(1)
	}

	var result AutoGenerated
	if err := json.Unmarshal(responseData, &result); err != nil {
		fmt.Println("Can't unmarshal JSON")
	}
	city := result.Name
	weatherDescription := result.Weather[0].Description
	weatherCondition := result.Weather[0].Main

	weatherTemp := fmt.Sprintf("%.2f", result.Main.Temp)

	return city, weatherDescription, weatherCondition, weatherTemp

}

func main() {
	Token, exist := os.LookupEnv("TOKEN")
	if !exist {
		log.Println("Can't get Token from .env")
	}

	bot, err := tgbotapi.NewBotAPI(Token)
	if err != nil {
		log.Println(err)
		os.Exit(1)
	}

	bot.Debug = true
	// create a new updateConfig struct with an offset of 0. Offsets are used to make sure Telegram
	// knows we've handled previous values and we don't need them repeated
	updateConfig := tgbotapi.NewUpdate(0)

	// tell Telegram we should wait up to 120 seconds on each request for an update. This way we can get information just as quick
	// as making many frequent requests without having to send nearly as many.
	updateConfig.Timeout = 30

	// Start pooling Telegram for updates
	updates := bot.GetUpdatesChan(updateConfig)

	// let's go through each update that we're getting from Telegram
	for update := range updates {
		// Telegram can send many types of updates depending on wha tyour bot is up to.
		if update.Message == nil {
			continue
		}
		// Get weather
		if strings.ToLower(update.Message.Text) == "weather" {
			// get from weather api date
			city, desk, condition, temp := getWeatherDate()
			textMsg := "Город: " + city + "\nСостояние: " + condition + "\nКраткое Описание: " + desk + "\nТемпература: " + temp
			msg := tgbotapi.NewMessage(update.Message.Chat.ID, textMsg)

			// We're sending our message off! We don't care about the message
			// we just sent, so we'll discard it

			if _, err := bot.Send(msg); err != nil {
				log.Fatal(err)
			}

		} else {
			// Now that we know we've gotten a new messge, we can construct a reply!
			// We'll take the Chat ID and Text from the incoming message adn use it
			// to create a new message
			textMsg := update.Message.Text
			msg := tgbotapi.NewMessage(update.Message.Chat.ID, textMsg) // update.Message.Text

			// We'll also say that this message is a reply to the previous message.
			// For any other specifications than Chat ID or Text, you'll need to set fields on the `MessageConfig`.
			msg.ReplyToMessageID = update.Message.MessageID

			// We're sending our message off! We don't care about the message
			// we just sent, so we'll discard it

			if _, err := bot.Send(msg); err != nil {
				log.Fatal(err)
			}

		}

	}
}
